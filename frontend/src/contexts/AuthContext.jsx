import React, { createContext, useContext, useReducer, useEffect } from 'react';import authService from '../services/authService';const AuthContext = createContext()// Auth reducerconst authReducer = (state, action) => {  switch (action.type) {    case 'SET_LOADING':      return { ...state, loading: action.payload }    case 'SET_USER':      return {        ...state,        isAuthenticated: true,        user: action.payload.user,        organization: action.payload.organization,        loading: false,        error: null      }    case 'SET_ERROR':      return {        ...state,        error: action.payload,        loading: false      }    case 'LOGOUT':      return {        ...state,        isAuthenticated: false,        user: null,        organization: null,        loading: false,        error: null      }    case 'CLEAR_ERROR':      return { ...state, error: null }    default:      return state  }}const initialState = {  isAuthenticated: false,  user: null,  organization: null,  loading: true,  error: null}export const AuthProvider = ({ children }) => {  const [state, dispatch] = useReducer(authReducer, initialState)  // Check authentication on app load  useEffect(() => {    checkAuth()  }, [])  const checkAuth = async () => {    dispatch({ type: 'SET_LOADING', payload: true })        try {      if (!authService.isAuthenticated()) {        console.log('❌ No valid token found')        dispatch({ type: 'LOGOUT' })        return      }      const result = await authService.getCurrentUser()            if (result.success) {        console.log('✅ Auth check passed:', result.user)        dispatch({           type: 'SET_USER',           payload: {             user: result.user,             organization: result.organization           }         })      } else {        console.log('❌ Auth check failed:', result.error)        dispatch({ type: 'LOGOUT' })      }    } catch (error) {      console.error('❌ Auth check error:', error)      dispatch({ type: 'LOGOUT' })    }  }  const login = async (email, password) => {    dispatch({ type: 'SET_LOADING', payload: true })    dispatch({ type: 'CLEAR_ERROR' })    try {      const result = await authService.login(email, password)            if (result.success) {        console.log('✅ Login successful:', result.user)        dispatch({           type: 'SET_USER',           payload: {             user: result.user,             organization: result.organization           }         })        return { success: true }      } else {        console.log('❌ Login failed:', result.error)        dispatch({ type: 'SET_ERROR', payload: result.error })        return { success: false, error: result.error }      }    } catch (error) {      console.error('❌ Login error:', error)      dispatch({ type: 'SET_ERROR', payload: 'Login failed. Please try again.' })      return { success: false, error: 'Login failed. Please try again.' }    }  }  const logout = () => {    authService.logout()    dispatch({ type: 'LOGOUT' })    console.log('✅ Logged out successfully')  }  const register = async (userData) => {    dispatch({ type: 'SET_LOADING', payload: true })    dispatch({ type: 'CLEAR_ERROR' })    try {      const result = await authService.register(userData)            if (result.success) {        dispatch({           type: 'SET_USER',           payload: {             user: result.user,             organization: null           }         })        return { success: true }      } else {        dispatch({ type: 'SET_ERROR', payload: result.error })        return { success: false, error: result.error }      }    } catch (error) {      dispatch({ type: 'SET_ERROR', payload: 'Registration failed. Please try again.' })      return { success: false, error: 'Registration failed. Please try again.' }    }  }  const clearError = () => {    dispatch({ type: 'CLEAR_ERROR' })  }  const value = {    ...state,    login,    logout,    register,    checkAuth,    clearError  }  return (    <AuthContext.Provider value={value}>      {children}    </AuthContext.Provider>  )}export const useAuth = () => {  const context = useContext(AuthContext)  if (!context) {    throw new Error('useAuth must be used within an AuthProvider')  }  return context}